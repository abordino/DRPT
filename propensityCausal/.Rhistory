if (length(cand)) return(cand[1])
stop("Could not find a column for code ", code, " in names(df).")
}
# Try typical keywords; fall back to "whatever starts with H6/C6"
col_mask <- tryCatch(
find_policy_col(ox_nat, "H6", keywords = c("facial","mask","cover")),
error = function(e) find_policy_col(ox_nat, "H6")
)
col_stay <- tryCatch(
find_policy_col(ox_nat, "C6", keywords = c("stay","home","require")),
error = function(e) find_policy_col(ox_nat, "C6")
)
## =========================
## 0) Setup
## =========================
pkgs <- c("tidyverse","did","AER","lubridate","matrixStats")
to_install <- setdiff(pkgs, rownames(installed.packages()))
if (length(to_install)) install.packages(to_install, repos="https://cloud.r-project.org")
invisible(lapply(pkgs, library, character.only=TRUE))
theme_set(theme_minimal(base_size = 12))
## =========================
## 3) OxCGRT (mask / stay-at-home) — national, robust column detection
## =========================
suppressPackageStartupMessages({
library(dplyr); library(tidyr); library(ggplot2); library(lubridate); library(stringr)
})
# -- helper: robustly locate a policy column by code and keywords --
find_policy_col <- function(df, code, keywords = character()) {
nm <- names(df)
# candidates: start with code (e.g., C6_..., H6 ...), allow separators or exact
cand <- nm[str_detect(nm, regex(paste0("^", code, "([_ .-]|$)"), ignore_case = TRUE))]
if (length(keywords)) {
rx <- regex(paste(keywords, collapse = "|"), ignore_case = TRUE)
cand2 <- cand[str_detect(cand, rx)]
if (length(cand2)) return(cand2[1])
}
if (length(cand)) return(cand[1])
stop("Could not find a column for code ", code, " in names(df).")
}
# Try typical keywords; fall back to "whatever starts with H6/C6"
col_mask <- tryCatch(
find_policy_col(ox_nat, "H6", keywords = c("facial","mask","cover")),
error = function(e) find_policy_col(ox_nat, "H6")
)
col_stay <- tryCatch(
find_policy_col(ox_nat, "C6", keywords = c("stay","home","require")),
error = function(e) find_policy_col(ox_nat, "C6")
)
## =========================
## 0) Setup
## =========================
pkgs <- c("tidyverse","lubridate","stringr","readr","curl")
to_install <- setdiff(pkgs, rownames(installed.packages()))
if (length(to_install)) install.packages(to_install, repos="https://cloud.r-project.org")
invisible(lapply(pkgs, library, character.only = TRUE))
theme_set(theme_minimal(base_size = 12))
options(timeout = max(600, getOption("timeout", 60)))
## =========================
## 1) Download OxCGRT compact national (robust)
## =========================
get_oxcgrt_nat <- function() {
urls <- c(
# Raw link (GitHub "raw" domain)
"https://raw.githubusercontent.com/OxCGRT/covid-policy-dataset/main/data/OxCGRT_compact_national_v1.csv",
# GitHub /raw/ path (works behind some proxies)
"https://github.com/OxCGRT/covid-policy-dataset/raw/main/data/OxCGRT_compact_national_v1.csv"
)
last_err <- NULL
for (u in urls) {
message("Trying: ", u)
tmp <- tempfile(fileext = ".csv")
ok <- tryCatch({
curl::curl_download(u, tmp, mode = "wb", quiet = TRUE); TRUE
}, error = function(e) { last_err <<- e$message; FALSE })
if (!ok) {
ok2 <- tryCatch({
utils::download.file(u, tmp, mode = "wb", quiet = TRUE, method = "libcurl"); TRUE
}, error = function(e) { last_err <<- e$message; FALSE })
if (!ok2) next
}
if (file.exists(tmp) && file.size(tmp) > 1024) {
return(readr::read_csv(tmp, show_col_types = FALSE, progress = FALSE))
}
}
stop("All OxCGRT download attempts failed.", if (!is.null(last_err)) paste0(" Last error: ", last_err) else "")
}
ox_nat <- get_oxcgrt_nat()
glimpse(ox_nat)
## =========================
## 2) Pick policies, build staircase/tensor views
## =========================
# Robust policy column finder: prefer names starting with code and containing keywords
find_policy_col <- function(df, code, keywords = character()) {
nm <- names(df)
# start with code H6/C6 (allow separators); avoid picking *_flag / *_notes if possible
cand <- nm[str_detect(nm, regex(paste0("^", code, "([_ .-]|$)"), ignore_case = TRUE))]
if (length(keywords)) {
rx <- regex(paste(keywords, collapse="|"), ignore_case = TRUE)
cand2 <- cand[str_detect(cand, rx)]
# try to drop obvious flag/notes columns
cand2 <- cand2[!str_detect(cand2, regex("(flag|note|notes)$", ignore_case = TRUE))]
if (length(cand2)) return(cand2[1])
}
# fallback: any that start with code but not flag/notes
cand <- cand[!str_detect(cand, regex("(flag|note|notes)$", ignore_case = TRUE))]
if (length(cand)) return(cand[1])
stop("Could not find a column for code ", code, " in names(df).")
}
col_mask <- tryCatch(
find_policy_col(ox_nat, "H6", keywords = c("facial","mask","cover")),
error = function(e) find_policy_col(ox_nat, "H6")
)
col_stay <- tryCatch(
find_policy_col(ox_nat, "C6", keywords = c("stay","home","require")),
error = function(e) find_policy_col(ox_nat, "C6")
)
message("Using columns: mask = ", col_mask, " ; stay = ", col_stay)
## =========================
## 0) Setup
## =========================
pkgs <- c("tidyverse","lubridate","stringr","readr","curl")
to_install <- setdiff(pkgs, rownames(installed.packages()))
if (length(to_install)) install.packages(to_install, repos="https://cloud.r-project.org")
invisible(lapply(pkgs, library, character.only = TRUE))
theme_set(theme_minimal(base_size = 12))
options(timeout = max(600, getOption("timeout", 60)))
## =========================
## 1) Download OxCGRT compact national (robust)
## =========================
get_oxcgrt_nat <- function() {
urls <- c(
# Raw link (GitHub "raw" domain)
"https://raw.githubusercontent.com/OxCGRT/covid-policy-dataset/main/data/OxCGRT_compact_national_v1.csv",
# GitHub /raw/ path (works behind some proxies)
"https://github.com/OxCGRT/covid-policy-dataset/raw/main/data/OxCGRT_compact_national_v1.csv"
)
last_err <- NULL
for (u in urls) {
message("Trying: ", u)
tmp <- tempfile(fileext = ".csv")
ok <- tryCatch({
curl::curl_download(u, tmp, mode = "wb", quiet = TRUE); TRUE
}, error = function(e) { last_err <<- e$message; FALSE })
if (!ok) {
ok2 <- tryCatch({
utils::download.file(u, tmp, mode = "wb", quiet = TRUE, method = "libcurl"); TRUE
}, error = function(e) { last_err <<- e$message; FALSE })
if (!ok2) next
}
if (file.exists(tmp) && file.size(tmp) > 1024) {
return(readr::read_csv(tmp, show_col_types = FALSE, progress = FALSE))
}
}
stop("All OxCGRT download attempts failed.", if (!is.null(last_err)) paste0(" Last error: ", last_err) else "")
}
ox_nat <- get_oxcgrt_nat()
glimpse(ox_nat)
## =========================
## 2) Pick policies, build staircase/tensor views
## =========================
# Robust policy column finder: prefer names starting with code and containing keywords
find_policy_col <- function(df, code, keywords = character()) {
nm <- names(df)
# start with code H6/C6 (allow separators); avoid picking *_flag / *_notes if possible
cand <- nm[str_detect(nm, regex(paste0("^", code, "([_ .-]|$)"), ignore_case = TRUE))]
if (length(keywords)) {
rx <- regex(paste(keywords, collapse="|"), ignore_case = TRUE)
cand2 <- cand[str_detect(cand, rx)]
# try to drop obvious flag/notes columns
cand2 <- cand2[!str_detect(cand2, regex("(flag|note|notes)$", ignore_case = TRUE))]
if (length(cand2)) return(cand2[1])
}
# fallback: any that start with code but not flag/notes
cand <- cand[!str_detect(cand, regex("(flag|note|notes)$", ignore_case = TRUE))]
if (length(cand)) return(cand[1])
stop("Could not find a column for code ", code, " in names(df).")
}
col_mask <- tryCatch(
find_policy_col(ox_nat, "H6", keywords = c("facial","mask","cover")),
error = function(e) find_policy_col(ox_nat, "H6")
)
## =========================
## 0) Setup
## =========================
pkgs <- c("tidyverse","did","AER","lubridate","matrixStats","stringr","readr","curl")
to_install <- setdiff(pkgs, rownames(installed.packages()))
if (length(to_install)) install.packages(to_install, repos="https://cloud.r-project.org")
invisible(lapply(pkgs, library, character.only=TRUE))
theme_set(theme_minimal(base_size = 12))
options(timeout = max(600, getOption("timeout", 60)))
## =========================
## 3) OxCGRT (mask mandates / stay-at-home) — country-level
## =========================
# Download (or re-use) the compact national CSV
if (!exists("ox_nat")) {
ox_nat <- readr::read_csv(
"https://github.com/OxCGRT/covid-policy-dataset/raw/main/data/OxCGRT_compact_national_v1.csv",
show_col_types = FALSE
)
}
glimpse(ox_nat)
## =========================
## OxCGRT: pick policies, build staircase/tensor views
## =========================
# robust finder: supports H6 / H6M (and C6 / C6M), avoids *_Flag / *_Notes
find_policy_col2 <- function(df, code, keywords = character()) {
nm <- names(df)
# allow optional 'M' after code, then a separator
prefix_rx <- paste0("^", code, "M?([_ .-]|$)")
cand <- nm[str_detect(nm, regex(prefix_rx, ignore_case = TRUE))]
if (!length(cand)) stop("No columns starting with ", code, " or ", code, "M found.")
# drop flags/notes
cand <- cand[!str_detect(cand, regex("(flag|note|notes)$", ignore_case = TRUE))]
if (length(keywords)) {
kw_rx <- regex(paste(keywords, collapse="|"), ignore_case = TRUE)
cand_kw <- cand[str_detect(cand, kw_rx)]
if (length(cand_kw)) return(cand_kw[1])
}
# fallback: first non-flag/notes candidate
cand[1]
}
# your file shows: `H6M_Facial Coverings`, `C6M_Stay at home requirements`
col_mask <- find_policy_col2(ox_nat, "H6", keywords = c("facial","cover","mask"))
col_stay <- find_policy_col2(ox_nat, "C6", keywords = c("stay","home","require"))
message("Using OxCGRT columns: mask = ", col_mask, " ; stay = ", col_stay)
# countries + time window
keep_cty <- c("United States","United Kingdom","Italy","Spain","Germany","France","Canada","Japan")
ox2 <- ox_nat %>%
filter(CountryName %in% keep_cty) %>%
transmute(
country = CountryName,
# Date is numeric like 20200315; coerce safely
date    = lubridate::ymd(as.character(Date)),
mask    = .data[[col_mask]],
stay    = .data[[col_stay]]
) %>%
filter(date >= as.Date("2020-02-15"), date <= as.Date("2020-08-31"))
# Binary adoption (≥ 2)
ox2 <- ox2 %>%
mutate(
mask_on = !is.na(mask) & mask >= 2,
stay_on = !is.na(stay) & stay >= 2
)
# Staircase heatmap: MASK (label 10 random countries)
set.seed(123)
y_breaks <- sample(unique(ox2$country), size = min(10, length(unique(ox2$country))))
ox_long_mask <- ox2 %>%
select(country, date, on = mask_on) %>%
mutate(country = factor(country, levels = keep_cty))
ggplot(ox_long_mask, aes(x = date, y = country, fill = on)) +
geom_tile() +
scale_fill_manual(values = c("grey90","firebrick"), labels = c("No","Yes")) +
scale_y_discrete(breaks = y_breaks) +
labs(title = "OxCGRT (compact): mask mandate adoption (H6M ≥ 2)",
x = "Date (2020)", y = "Country", fill = "Mask on") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Aggregate staircase: share treated (MASK)
share_mask <- ox_long_mask %>%
group_by(date) %>% summarize(pct = mean(on, na.rm = TRUE), .groups = "drop")
ggplot(share_mask, aes(date, pct)) +
geom_line() +
scale_y_continuous(labels = scales::percent) +
labs(title = "Share of countries with mask mandate (≥ 2)",
x = "Date (2020)", y = "Share treated")
# Tensor view: country × date × policy (facet by policy)
ox_long_tensor <- ox2 %>%
transmute(country, date,
`Mask (H6M ≥ 2)` = mask_on,
`Stay-at-home (C6M ≥ 2)` = stay_on) %>%
pivot_longer(-c(country, date), names_to = "policy", values_to = "on") %>%
mutate(country = factor(country, levels = keep_cty))
ggplot(ox_long_tensor, aes(x = date, y = country, fill = on)) +
geom_tile() +
facet_wrap(~ policy, ncol = 1) +
scale_fill_manual(values = c("grey90","steelblue"), labels = c("No","Yes")) +
scale_y_discrete(breaks = y_breaks) +
labs(title = "Tensor view: country × date × policy (binary adoption ≥ 2)",
x = "Date (2020)", y = "Country", fill = "On") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# OPTIONAL: 4-block slice (cohort vs controls, pre/post) for MASK
first_on <- ox2 %>%
group_by(country) %>%
summarize(first_mask_on = suppressWarnings(min(date[mask_on], na.rm = TRUE)),
.groups = "drop") %>%
mutate(first_mask_on = ifelse(is.infinite(first_mask_on), NA, first_mask_on))
cohort_date <- first_on %>%
filter(!is.na(first_mask_on)) %>%
count(first_mask_on, sort = TRUE) %>%
slice(1) %>% pull(first_mask_on)
## =========================
## OxCGRT — generalized staircase for ALL policy columns
## =========================
suppressPackageStartupMessages({
library(dplyr); library(tidyr); library(ggplot2)
library(stringr); library(lubridate); library(purrr)
})
# -------- 1) Choose countries + window (edit if you like) --------
keep_cty <- c("United States","United Kingdom","Italy","Spain","Germany","France","Canada","Japan")
date_lo  <- as.Date("2020-02-15")
date_hi  <- as.Date("2020-08-31")
ox_base <- ox_nat %>%
filter(CountryName %in% keep_cty) %>%
transmute(
country = CountryName,
date    = ymd(as.character(Date)),
across(everything(), identity)
) %>%
filter(date >= date_lo, date <= date_hi)
# -------- 2) Detect ALL numeric policy columns (C*, H*, E*, V*), drop *Flag/*Notes --------
all_policy_cols <- names(ox_base)
policy_cols <- all_policy_cols[
str_detect(all_policy_cols, regex("^(C[1-8]|E[1-4]|H[1-8]|V[1-4])[A-Z]*_", ignore_case = TRUE)) &
!str_detect(all_policy_cols, regex("(flag|note|notes)$", ignore_case = TRUE))
]
# keep only numeric
policy_cols <- policy_cols[sapply(ox_base[policy_cols], is.numeric)]
# derive short policy code (e.g., H6M, C6M, C8EV, E1, ...)
policy_meta <- tibble(col = policy_cols) %>%
mutate(code = str_extract(col, "^(C[1-8]|E[1-4]|H[1-8]|V[1-4])[A-Z]*"))
# -------- 3) Policy-specific ON thresholds  --------
# Heuristic: if max <= 1  -> threshold = 1 (binary policies)
#            else          -> threshold = 2 (ordinal policies where 2+ is meaningful)
#            For E* and V* we often use >=1 to mark activation
threshold_for <- function(code, x) {
mx <- suppressWarnings(max(x, na.rm = TRUE))
if (!is.finite(mx)) return(1)
if (startsWith(code, "E") || startsWith(code, "V")) return(1)
if (mx <= 1) return(1)
2
}
policy_meta <- policy_meta %>%
rowwise() %>%
mutate(thresh = threshold_for(code, ox_base[[col]])) %>%
ungroup()
# -------- 4) Helper to build sorted on/off data per policy --------
build_sorted_panel <- function(col, code, thresh) {
df <- ox_base %>%
select(country, date, value = all_of(col)) %>%
arrange(country, date) %>%
mutate(on = !is.na(value) & value >= thresh)
# order countries by FIRST adoption (NAs last)
ord <- df %>%
group_by(country) %>%
summarize(first_on = suppressWarnings(min(date[on], na.rm = TRUE)), .groups = "drop") %>%
mutate(first_on = ifelse(is.infinite(first_on), as.Date(NA), first_on)) %>%
arrange(is.na(first_on), first_on, country) %>%
mutate(y = row_number())
df2 <- df %>%
inner_join(ord, by = "country") %>%
arrange(y, date)
list(df = df2, ord = ord, code = code, thr = thresh, col = col)
}
panels <- pmap(policy_meta, ~build_sorted_panel(..1, ..2, ..3))
# -------- 5) Plot functions: RAW and MONOTONE (“ever on”) --------
pick_breaks <- function(y_vals, n = 10) {
ys <- unique(y_vals)
if (length(ys) <= n) ys else sample(ys, n)
}
plot_policy <- function(obj, monotone = FALSE) {
d <- obj$df
if (monotone) {
d <- d %>%
group_by(country) %>%
arrange(date, .by_group = TRUE) %>%
mutate(on = as.logical(cummax(as.integer(on)))) %>%
ungroup()
}
# y-axis labels: 10 random countries
brks <- pick_breaks(d$y, 10)
labs_tbl <- d %>% distinct(y, country) %>% filter(y %in% brks)
ggplot(d, aes(x = date, y = y, fill = on)) +
geom_tile() +
scale_fill_manual(values = c("grey90","firebrick"), labels = c("No","Yes")) +
scale_y_continuous("Country (sorted by first adoption)",
breaks = labs_tbl$y, labels = labs_tbl$country) +
labs(
title = sprintf("%s  (code: %s,  threshold ≥ %g)  %s",
obj$col, obj$code, obj$thr,
if (monotone) "— MONOTONE ever-on" else "— RAW on/off"),
x = "Date", y = NULL, fill = "On"
) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
# -------- 6) RUN: loop through ALL detected policies and plot --------
# Set to TRUE if you want to also plot the monotone version for each policy
also_plot_monotone <- TRUE
for (p in panels) {
print(plot_policy(p, monotone = FALSE))
if (also_plot_monotone) print(plot_policy(p, monotone = TRUE))
}
# -------- 7) (Optional) Save all plots to a PDF  --------
# pdf("oxcgrt_staircases_all_policies.pdf", width = 10, height = 7)
# for (p in panels) {
#   print(plot_policy(p, monotone = FALSE))
#   if (also_plot_monotone) print(plot_policy(p, monotone = TRUE))
# }
# dev.off()
pdf("oxcgrt_staircases_all_policies.pdf", width = 10, height = 7)
for (p in panels) {
print(plot_policy(p, monotone = FALSE))
if (also_plot_monotone) print(plot_policy(p, monotone = TRUE))
}
dev.off()
setwd("~/Documents/phd/projects/causalMatrix/code/real-world/covid")
pdf("oxcgrt_staircases_all_policies.pdf", width = 10, height = 7)
for (p in panels) {
print(plot_policy(p, monotone = FALSE))
if (also_plot_monotone) print(plot_policy(p, monotone = TRUE))
}
dev.off()
# ==========================================
# Causal DGP, LL ratio, DRPT (E1), save decisions
# ==========================================
rm(list = ls()); gc()
setwd("~/Documents/phd/projects/DRPT/code/simulationCpp/propensityCausal/")
# setwd("/storage/stats/strtng/SPT/syntheticCausal/")
# --- deps ---
pkgs = c("MASS","DRPT","kerTests", "latex2exp")
need = pkgs[!sapply(pkgs, requireNamespace, quietly = TRUE)]
if (length(need) > 0) install.packages(need)
invisible(lapply(pkgs, library, character.only = TRUE))
set.seed(170966)
# --- Plot (unchanged inputs) ---
data.LL  = read.csv(file = "experiments/results/ll_drpt_power.csv")
data.KLR   = read.csv(file = "experiments/results/kliep_drpt_power.csv")
# MC must be defined in your environment
MC = 100
compute_sd = function(power) {
m = power
sqrt(m * (1 - m) / MC)
}
sd_LL = compute_sd(data.LL$power)
sd_KLR  = compute_sd(data.KLR$power)
# Helper to draw error bars, clipped to [0,1]
add_err = function(x, y, sd, col) {
ylow  = pmax(0, y - sd)
yhigh = pmin(1, y + sd)
arrows(x0 = x, y0 = ylow, x1 = x, y1 = yhigh,
angle = 90, code = 3, length = 0.04,
col = col, lwd = 1.3)
}
# Compute y-limits considering error bars
all_low  = pmin(data.LL$power  - sd_LL,
data.KLR$power   - sd_KLR, na.rm = TRUE)
all_high = pmax(data.LL$power  + sd_LL,
data.KLR$power   + sd_KLR, na.rm = TRUE)
ylim_use = c(max(0, min(all_low, na.rm = TRUE)),
min(1, max(all_high, na.rm = TRUE)))
dir.create("experiments/pictures", recursive = TRUE, showWarnings = FALSE)
png("experiments/pictures/Propensity.png")
par(mfrow = c(1, 1))
plot(data.LL$gamma, data.LL$power, type = "b",
col = "darkviolet", lwd = 2, pch = 14,
xlab = TeX(r'($\gamma$)', bold = TRUE), ylab = "Power",
ylim = ylim_use)
# Other series
lines(data.KLR$gamma, data.KLR$power,
type = "b", col = "orange", lwd = 2, pch = 16)
# SD segment bars
add_err(data.LL$gamma, data.LL$power,        sd_LL, "darkviolet")
add_err(data.KLR$gamma, data.KLR$power,        sd_KLR, "orange")
legend("topleft", inset = 0.01, horiz = FALSE, lty = 1, bty = "n",
legend = c("(E1) - LL", "(E1) - KLR"),
col = c("darkviolet", "orange"),
pch = c(14, 16))
abline(h = 0.05, col = "red", lty = 2)
dev.off()
# --- Plot (unchanged inputs) ---
data.LL  = read.csv(file = "experiments/results/ll_drpt_power.csv")
data.KLR   = read.csv(file = "experiments/results/klr_irls_drpt_power.csv")
# MC must be defined in your environment
MC = 100
compute_sd = function(power) {
m = power
sqrt(m * (1 - m) / MC)
}
sd_LL = compute_sd(data.LL$power)
sd_KLR  = compute_sd(data.KLR$power)
# Helper to draw error bars, clipped to [0,1]
add_err = function(x, y, sd, col) {
ylow  = pmax(0, y - sd)
yhigh = pmin(1, y + sd)
arrows(x0 = x, y0 = ylow, x1 = x, y1 = yhigh,
angle = 90, code = 3, length = 0.04,
col = col, lwd = 1.3)
}
# Compute y-limits considering error bars
all_low  = pmin(data.LL$power  - sd_LL,
data.KLR$power   - sd_KLR, na.rm = TRUE)
all_high = pmax(data.LL$power  + sd_LL,
data.KLR$power   + sd_KLR, na.rm = TRUE)
ylim_use = c(max(0, min(all_low, na.rm = TRUE)),
min(1, max(all_high, na.rm = TRUE)))
dir.create("experiments/pictures", recursive = TRUE, showWarnings = FALSE)
png("experiments/pictures/Propensity.png")
par(mfrow = c(1, 1))
plot(data.LL$gamma, data.LL$power, type = "b",
col = "darkviolet", lwd = 2, pch = 14,
xlab = TeX(r'($\gamma$)', bold = TRUE), ylab = "Power",
ylim = ylim_use)
# Other series
lines(data.KLR$gamma, data.KLR$power,
type = "b", col = "orange", lwd = 2, pch = 16)
# SD segment bars
add_err(data.LL$gamma, data.LL$power,        sd_LL, "darkviolet")
add_err(data.KLR$gamma, data.KLR$power,        sd_KLR, "orange")
legend("topleft", inset = 0.01, horiz = FALSE, lty = 1, bty = "n",
legend = c("(E1) - LL", "(E1) - KLR"),
col = c("darkviolet", "orange"),
pch = c(14, 16))
abline(h = 0.05, col = "red", lty = 2)
dev.off()
